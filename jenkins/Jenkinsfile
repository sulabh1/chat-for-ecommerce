pipeline {
    agent any
     
    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = sh(script: ''' aws sts get-caller-identity --query Account --output text || echo "123456789012" ''', returnStdout: true).trim()
        ECR_MAIN = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/main-service"
        ECR_CHAT = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/chat-service"
        GIT_COMMIT_SHORT = sh(script:'git rev-parse --short HEAD', returnStdout: true).trim()
        IMAGE_TAG = "${env.BUILD_NUMBER}-${GIT_COMMIT_SHORT}"
        ECS_CLUSTER = "chat-app-cluster"
        ECS_SERVICE = "chat-app-service"
        ECS_TASK_FAMILY = "chat-app-task"
    }
    
    options {
        timeout(time: 60, unit: "MINUTES")
        buildDiscarder(logRotator(numToKeepStr: "10"))
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                sh '''
                    echo "===CICD Pipeline Started ==="
                    echo "Branch: ${GIT_BRANCH}"
                    echo "Commit: ${GIT_COMMIT}"
                    echo "Build: #${BUILD_NUMBER}"
                '''
            }
        }
        
        stage('System Diagnostics') {
            steps {
                sh '''
                    echo "=== SYSTEM DIAGNOSTICS ==="
                    echo "Checking build environment resources..."
                    
                    echo ""
                    echo "1. System Resources:"
                    echo "Memory:"
                    free -h
                    echo ""
                    echo "Disk Space:"
                    df -h
                    echo ""
                    echo "CPU Info:"
                    nproc
                    echo ""
                    echo "Load Average:"
                    uptime
                    
                    echo ""
                    echo "2. Docker Status:"
                    docker info 2>&1 | grep -E "(Server Version|Storage Driver|Total Memory|CPUs|Name)" || true
                    
                    echo ""
                    echo "3. Docker Resources:"
                    docker system df
                    
                    echo ""
                    echo "4. Network Connectivity Test:"
                    echo "Testing npm registry access..."
                    timeout 30 curl -I https://registry.npmjs.org/ 2>&1 | head -5 || echo "Curl test failed"
                    
                    echo ""
                    echo "5. Docker Network Test:"
                    cat > /tmp/Dockerfile.test << 'EOF'
FROM alpine:latest
RUN apk add --no-cache curl
RUN echo "Testing network..." && \
    curl -s -o /dev/null -w "npmjs.org: %{http_code}\\n" https://registry.npmjs.org/ && \
    echo "Network test complete"
EOF
                    
                    echo "Building test image with --network=host..."
                    timeout 2m docker build --network=host -f /tmp/Dockerfile.test -t network-test /tmp 2>&1 | tail -20
                    
                    rm -f /tmp/Dockerfile.test
                    docker rmi network-test 2>/dev/null || true
                    
                    echo "✓ System diagnostics completed"
                '''
            }
        }
        
        stage('Setup Environment') {
            steps {
                sh '''
                    echo "=== Setting up Environment ==="
                    
                    # Create .env file if it doesn't exist
                    if [ ! -f .env ]; then
                        echo "Creating .env file for CI/CD..."
                        cat > .env << 'EOF'
# Database Configuration
DB_HOST=postgres-main
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=password
DB_DATABASE=ecommerce

# Chat Database Configuration
CHAT_DB_HOST=postgres-chat
CHAT_DB_PORT=5432
CHAT_DB_USERNAME=postgres
CHAT_DB_PASSWORD=password
CHAT_DB_NAME=chat_db

# JWT Secret
JWT_SECRET=test_jwt_secret_for_ci_cd

# Kafka Configuration
KAFKA_BROKERS=kafka:9092

# Node Environment
NODE_ENV=test
EOF
                        echo ".env file created for CI/CD"
                    else
                        echo ".env file already exists"
                    fi
                    
                    # Display .env file (without passwords for security)
                    echo "Current .env file contents (masked):"
                    cat .env | sed 's/\\(PASSWORD=\\|JWT_SECRET=\\).*/\\1***MASKED***/' || true
                '''
            }
        }
        
        stage('Analyze Docker Compose') {
            steps {
                sh '''
                    echo "=== Analyzing Docker Compose ==="
                    
                    # 1. Validate syntax (continue even with warnings)
                    echo "Validating docker-compose syntax..."
                    
                    # Save output to file and capture exit code
                    docker-compose config > docker-compose-validation.log 2>&1
                    DOCKER_COMPOSE_EXIT=$?
                    
                    if [ $DOCKER_COMPOSE_EXIT -eq 0 ]; then
                        echo "✓ Docker Compose syntax is valid"
                        echo "Note: Warning about 'version' attribute is expected and can be ignored"
                    else
                        echo "✗ Docker Compose syntax error"
                        cat docker-compose-validation.log
                        exit 1
                    fi

                    # 2. Check services
                    echo ""
                    echo "Services found:"
                    docker-compose config --services | sed 's/^/ - /'

                    # 3. Check for port conflicts - SIMPLIFIED
                    echo ""
                    echo "Checking port mappings..."
                    echo "Checking ports from docker-compose.yml..."
                    
                    # Extract ports from docker-compose config
                    PORTS=$(docker-compose config | grep -E "ports:|published:" | grep -v "^#" || true)
                    if [ -n "$PORTS" ]; then
                        echo "Exposed ports:"
                        echo "$PORTS" | sed 's/^/ - /'
                    else
                        echo "No ports exposed to host (services use internal networking)"
                    fi

                    # 4. Check for common issues
                    echo ""
                    echo "Checking for common issues..."

                    # Check networks
                    NETWORK_CHECK=$(docker-compose config | grep -A5 "services:" | grep -B5 "image:" | grep "networks:" || true)
                    if [ -z "$NETWORK_CHECK" ]; then
                        echo "Warning: Some services might not have networks defined"
                    else
                        echo "✓ Services have network configuration"
                    fi
                    
                    # Check for restart policies
                    RESTART_COUNT=$(docker-compose config | grep -c "restart:" || echo "0")
                    echo "Services with restart policy: $RESTART_COUNT"

                    # Check for depends_on
                    DEPENDS_COUNT=$(docker-compose config | grep -c "depends_on:" || echo "0")
                    echo "Services with dependencies: $DEPENDS_COUNT"
                    
                    echo "✓ Docker Compose analysis completed"
                '''
            }
        }
        
        stage('Security Scan') {
            steps {
                sh '''
                    echo "=== SECURITY SCANNING ==="
                    
                    echo "1. Checking Dockerfiles..."

                    # Check Dockerfile.main
                    if [ -f "Dockerfile.main" ]; then
                        echo "Dockerfile.main:"
                        if grep -q "^USER root" Dockerfile.main; then
                            echo "  ⚠️  Warning: Running as root - consider using non-root user"
                        else
                            echo "  ✓ Running as non-root user"
                        fi
                        if grep -q "COPY \\\\. \\\\.$" Dockerfile.main; then 
                            echo "  ⚠️  Warning: COPY . . copies everything - ensure .dockerignore is properly configured"
                        else
                            echo "  ✓ COPY command looks good"
                        fi
                        echo "  ✓ Dockerfile.main checks completed"
                    else
                        echo "  ✗ Dockerfile.main not found"
                    fi

                    # Check Dockerfile.chat
                    if [ -f "Dockerfile.chat" ]; then
                        echo "Dockerfile.chat:"
                        if grep -q "^USER root" Dockerfile.chat; then
                            echo "  ⚠️  Warning: Running as root - consider using non-root user"
                        else
                            echo "  ✓ Running as non-root user"
                        fi
                        echo "  ✓ Dockerfile.chat checks completed"
                    else
                        echo "  ✗ Dockerfile.chat not found"
                    fi

                    # Check for hardcoded secrets - SIMPLIFIED VERSION
                    echo ""
                    echo "2. Checking for hardcoded secrets..."
                    # Use a simpler approach without complex regex
                    SECRETS_FOUND=$(docker-compose config | grep -i -E "(password|secret|key)" | grep -v "#" | wc -l || echo "0")
                    if [ "$SECRETS_FOUND" -gt 0 ]; then
                        echo "  ⚠️  Found $SECRETS_FOUND lines with password/secret/key references"
                        echo "  (This is expected since we're using .env file for actual values)"
                    else
                        echo "  ✓ No password/secret/key references found"
                    fi

                    # Check .env files in git
                    echo ""
                    echo "3. Checking .env files in git..."
                    ENV_FILES_COUNT=$(git ls-files | grep -c '^\\.env' || echo "0")
                    if [ "$ENV_FILES_COUNT" -gt 0 ]; then
                        echo "  ⚠️  Warning: .env files found in git - consider adding them to .gitignore"
                        git ls-files | grep '^\\.env' || true
                    else
                        echo "  ✓ No .env files in git"
                    fi
                    
                    echo "✓ Security scan completed"
                '''
            }
        }
        
        stage('Docker Build Troubleshooting') {
            steps {
                sh '''
                    echo "=== DOCKER BUILD TROUBLESHOOTING ==="
                    
                    echo "1. Cleaning Docker cache and resources..."
                    docker builder prune -f 2>/dev/null || true
                    echo "✓ Docker builder cache cleared"
                    
                    echo ""
                    echo "2. Analyzing Dockerfile.main..."
                    if [ -f "Dockerfile.main" ]; then
                        echo "Dockerfile.main line count: $(wc -l < Dockerfile.main)"
                        echo "Lines with RUN commands:"
                        grep -n "^RUN" Dockerfile.main || echo "No RUN commands found"
                        
                        # Check for long-running commands
                        echo ""
                        echo "Checking for potential long-running operations..."
                        if grep -q "npm install" Dockerfile.main; then
                            echo "⚠ Found 'npm install' - this can be slow"
                        fi
                        if grep -q "apt-get install\\|apk add\\|yum install" Dockerfile.main; then
                            echo "⚠ Found package manager install - check packages"
                        fi
                    else
                        echo "✗ Dockerfile.main not found"
                    fi
                    
                    echo ""
                    echo "3. Testing incremental build..."
                    echo "Creating simplified test Dockerfile..."
                    
                    # Create a minimal test Dockerfile
                    cat > Dockerfile.test << 'EOF'
FROM node:20-alpine AS stage1
RUN echo "Stage 1: Testing basic operations" && \
    echo "Current directory: $(pwd)" && \
    ls -la / 2>/dev/null | head -5

FROM node:20-alpine AS stage2
RUN echo "Stage 2: Testing npm operations" && \
    npm init -y --silent && \
    echo "npm init successful"

FROM node:20-alpine
RUN echo "Final stage: Build complete" && \
    echo "✓ Test build successful"
EOF
                    
                    echo "Building test image with --progress=plain..."
                    timeout 3m docker build \
                        --network=host \
                        --progress=plain \
                        -f Dockerfile.test \
                        -t docker-test-build . 2>&1 | tee /tmp/docker-test.log
                    
                    TEST_EXIT=$?
                    if [ $TEST_EXIT -eq 0 ]; then
                        echo "✓ Test build successful"
                        docker rmi docker-test-build 2>/dev/null || true
                        rm -f Dockerfile.test
                    elif [ $TEST_EXIT -eq 124 ]; then
                        echo "✗ Test build timed out"
                        echo "Last 50 lines of log:"
                        tail -50 /tmp/docker-test.log
                        exit 1
                    else
                        echo "✗ Test build failed with code: $TEST_EXIT"
                        echo "Last 50 lines of log:"
                        tail -50 /tmp/docker-test.log
                        exit 1
                    fi
                    
                    echo "✓ Docker build troubleshooting completed"
                '''
            }
        }
        
        stage('Build Images (Optimized)') {
            options {
                timeout(time: 25, unit: 'MINUTES')
            }
            steps {
                script {
                    echo "=== BUILDING IMAGES (OPTIMIZED) ==="
                    
                    // Clean up before build
                    sh '''
                        echo "Cleaning up before build..."
                        docker system prune -f 2>/dev/null || true
                    '''
                    
                    // Build main-service in chunks
                    echo "Building main-service incrementally..."
                    
                    // Step 1: Build base layers
                    sh '''
                        echo "Step 1: Building base layers..."
                        timeout 5m docker build \
                            --network=host \
                            --progress=plain \
                            --target builder \
                            -f Dockerfile.main \
                            -t main-service-builder:${IMAGE_TAG} \
                            . 2>&1 | tee /tmp/build-step1.log || echo "Continuing with next step..."
                    '''
                    
                    // Step 2: Build final image
                    echo "Step 2: Building final main-service image..."
                    
                    try {
                        timeout(time: 15, unit: 'MINUTES') {
                            sh '''
                                echo "Building main-service (full build)..."
                                docker build \
                                    --network=host \
                                    --progress=plain \
                                    --no-cache \
                                    --build-arg NODE_ENV=test \
                                    -f Dockerfile.main \
                                    -t main-service:${IMAGE_TAG} \
                                    . 2>&1 | tee /tmp/build-main.log
                                    
                                # Check if build was successful
                                if docker images | grep -q "main-service.*${IMAGE_TAG}"; then
                                    echo "✓ main-service built successfully"
                                    docker tag main-service:${IMAGE_TAG} main-service:latest
                                else
                                    echo "✗ main-service build failed - checking logs..."
                                    tail -100 /tmp/build-main.log
                                    exit 1
                                fi
                            '''
                        }
                    } catch (Exception e) {
                        echo "Build failed: ${e}"
                        
                        // Try alternative approach
                        echo "Trying alternative build approach..."
                        sh '''
                            echo "Alternative: Building with reduced context..."
                            # Create minimal context
                            mkdir -p /tmp/docker-build
                            cp Dockerfile.main /tmp/docker-build/
                            cp -r apps/main-service /tmp/docker-build/ 2>/dev/null || true
                            cp package*.json /tmp/docker-build/ 2>/dev/null || true
                            cp nest-cli.json /tmp/docker-build/ 2>/dev/null || true
                            cp tsconfig*.json /tmp/docker-build/ 2>/dev/null || true
                            
                            timeout 10m docker build \
                                --network=host \
                                --progress=plain \
                                --build-arg NODE_ENV=test \
                                -f /tmp/docker-build/Dockerfile.main \
                                -t main-service:${IMAGE_TAG} \
                                /tmp/docker-build 2>&1 | tee /tmp/build-alt.log
                                
                            if docker images | grep -q "main-service.*${IMAGE_TAG}"; then
                                echo "✓ Alternative build successful"
                                docker tag main-service:${IMAGE_TAG} main-service:latest
                            else
                                echo "✗ Alternative build also failed"
                                tail -100 /tmp/build-alt.log
                                exit 1
                            fi
                        '''
                    }
                    
                    // Build chat-service
                    echo "Building chat-service..."
                    
                    try {
                        timeout(time: 15, unit: 'MINUTES') {
                            sh '''
                                echo "Building chat-service..."
                                docker build \
                                    --network=host \
                                    --progress=plain \
                                    --no-cache \
                                    --build-arg NODE_ENV=test \
                                    -f Dockerfile.chat \
                                    -t chat-service:${IMAGE_TAG} \
                                    . 2>&1 | tee /tmp/build-chat.log
                                    
                                if docker images | grep -q "chat-service.*${IMAGE_TAG}"; then
                                    echo "✓ chat-service built successfully"
                                    docker tag chat-service:${IMAGE_TAG} chat-service:latest
                                else
                                    echo "✗ chat-service build failed"
                                    tail -100 /tmp/build-chat.log
                                    exit 1
                                fi
                            '''
                        }
                    } catch (Exception e) {
                        echo "Chat-service build failed: ${e}"
                        // Continue anyway for testing
                        echo "⚠ Continuing pipeline despite chat-service build failure"
                    }
                    
                    echo "✓ Build process completed"
                    sh '''
                        echo "Final images:"
                        docker images | grep -E "(main-service|chat-service)" || echo "No images built"
                    '''
                }
            }
        }
        
        stage('Run Tests') {
            when {
                expression { 
                    // Only run if images were built
                    sh(script: 'docker images | grep -q "main-service" && echo "true" || echo "false"', returnStdout: true).trim() == 'true'
                }
            }
            steps {
                sh '''
                    echo "=== Running Tests ==="
                    echo "Starting test environment..."
                    
                    # Start required services
                    docker-compose up -d postgres-main postgres-chat zookeeper kafka
                    
                    echo "Waiting for services to start..."
                    sleep 30

                    echo "Checking service status..."
                    docker-compose ps

                    echo "Checking if databases are ready..."
                    # Wait for PostgreSQL to be ready
                    for i in {1..30}; do
                        if docker-compose exec -T postgres-main pg_isready -U postgres > /dev/null 2>&1 && \
                           docker-compose exec -T postgres-chat pg_isready -U postgres > /dev/null 2>&1; then
                            echo "✓ Databases are ready"
                            break
                        fi
                        if [ $i -eq 30 ]; then
                            echo "✗ Databases not ready after 30 seconds"
                            docker-compose logs postgres-main
                            docker-compose logs postgres-chat
                            exit 1
                        fi
                        sleep 1
                    done

                    # Basic health checks
                    echo "Running basic health checks..."
                    
                    # Check if services are running
                    RUNNING_SERVICES=$(docker-compose ps --services --filter "status=running" | wc -l)
                    TOTAL_SERVICES=$(docker-compose ps --services | wc -l)
                    
                    if [ "$RUNNING_SERVICES" -eq "$TOTAL_SERVICES" ]; then
                        echo "✓ All services are running ($RUNNING_SERVICES/$TOTAL_SERVICES)"
                    else
                        echo "⚠️  Some services not running ($RUNNING_SERVICES/$TOTAL_SERVICES)"
                        docker-compose ps
                    fi

                    # Stop services
                    echo "Stopping test environment..."
                    docker-compose down

                    echo "✓ Tests completed"
                '''
            }
        }
        
        stage('Push to ECR') {
            when {
                allOf {
                    branch "master"
                    expression { 
                        sh(script: 'docker images | grep -q "main-service" && echo "true" || echo "false"', returnStdout: true).trim() == 'true'
                    }
                }
            }
            steps {
                script {
                    sh '''
                        echo "=== Pushing to AWS ECR ==="

                        echo "Logging into ECR..."
                        aws ecr get-login-password --region ${AWS_REGION} | \
                        docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

                        # Create ECR repositories if they don't exist
                        echo "Checking ECR repositories..."
                        for repo in main-service chat-service; do
                            if ! aws ecr describe-repositories --repository-names $repo --region ${AWS_REGION} > /dev/null 2>&1; then
                                echo "Creating repository: $repo"
                                aws ecr create-repository --repository-name $repo --region ${AWS_REGION}
                            fi
                        done

                        # Tag and push main-service
                        echo "Pushing main-service..."
                        docker tag main-service:${IMAGE_TAG} ${ECR_MAIN}:${IMAGE_TAG}
                        docker tag main-service:${IMAGE_TAG} ${ECR_MAIN}:latest
                        docker push ${ECR_MAIN}:${IMAGE_TAG} || echo "Push failed for ${ECR_MAIN}:${IMAGE_TAG}"
                        docker push ${ECR_MAIN}:latest || echo "Push failed for ${ECR_MAIN}:latest"

                        # Tag and push chat-service
                        echo "Pushing chat-service..."
                        docker tag chat-service:${IMAGE_TAG} ${ECR_CHAT}:${IMAGE_TAG}
                        docker tag chat-service:${IMAGE_TAG} ${ECR_CHAT}:latest
                        docker push ${ECR_CHAT}:${IMAGE_TAG} || echo "Push failed for ${ECR_CHAT}:${IMAGE_TAG}"
                        docker push ${ECR_CHAT}:latest || echo "Push failed for ${ECR_CHAT}:latest"

                        echo "✓ Images pushed to ECR:"
                        echo "  - ${ECR_MAIN}:${IMAGE_TAG}"
                        echo "  - ${ECR_CHAT}:${IMAGE_TAG}"
                    '''
                }
            }
        }
        
        stage('Deploy to ECS') {
            when {
                allOf {
                    branch 'master'
                    expression { 
                        sh(script: 'docker images | grep -q "main-service" && echo "true" || echo "false"', returnStdout: true).trim() == 'true'
                    }
                }
            }
            steps {
                script {
                    sh '''
                        echo "=== Deploying to AWS ECS ==="

                        # Check if deployment script exists
                        if [ -f "jenkins/scripts/deploy-ecs.sh" ]; then
                            chmod +x jenkins/scripts/deploy-ecs.sh
                            jenkins/scripts/deploy-ecs.sh ${IMAGE_TAG} ${AWS_REGION} ${ECS_CLUSTER} ${ECS_SERVICE} || echo "Deployment script failed"
                        else
                            echo "⚠️  No deployment script found at jenkins/scripts/deploy-ecs.sh"
                            echo "Skipping ECS deployment"
                        fi
                        
                        echo "✓ Deployment completed"
                    '''
                }
            }
        }
        
        stage('Health Check') {
            when {
                allOf {
                    branch 'master'
                    expression { 
                        sh(script: 'docker images | grep -q "main-service" && echo "true" || echo "false"', returnStdout: true).trim() == 'true'
                    }
                }
            }
            steps {
                sh '''
                    echo "=== Health Check ==="
                    # Wait for deployment to stabilize
                    echo "Waiting for services to be ready..."
                    sleep 60

                    # Run health check script
                    if [ -f "jenkins/scripts/health-check.sh" ]; then
                        chmod +x jenkins/scripts/health-check.sh
                        jenkins/scripts/health-check.sh || echo "Health checks completed with warnings"
                    else
                        echo "⚠️  No health check script found at jenkins/scripts/health-check.sh"
                        echo "Skipping health checks"
                    fi
                    echo "✓ Health checks completed"
                '''
            }
        }
    }
    
    post {
        always {
            sh '''
                echo "=== Cleanup ==="
                # Clean up Docker
                docker-compose down 2>/dev/null || true
                docker system prune -f 2>/dev/null || true
                docker volume prune -f 2>/dev/null || true
                # Clean up log files
                rm -f docker-compose-validation.log /tmp/build-*.log 2>/dev/null || true
                echo "=== Build ${BUILD_NUMBER} Completed ==="
            '''
        }
        success {
            echo "✅ Pipeline SUCCESS"
        }
        failure {
            echo "❌ Pipeline FAILED"
        }
        unstable {
            echo "⚠️  Pipeline UNSTABLE"
        }
    }
}